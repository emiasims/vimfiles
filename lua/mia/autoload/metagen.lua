-- for creating lua/mia/_meta_gen.lua

local F = setmetatable({
  _order = {},
}, {
  __newindex = function(t, k, v)
    table.insert(t._order, k)
    rawset(t, k, v)
  end,
})

local Iter = vim.iter

local function Formatter(fmt)
  return function(...)
    local fargs = { ... }
    return fmt
      :gsub('%%%d+', function(n)
        local arg = tonumber(n:sub(2)) --[[@as integer]]
        return vim.pesc(('%s'):format(select(arg, unpack(fargs))))
      end)
      :format(...)
  end
end

local sort = mia.tbl.sort

function F.header()
  return {
    '---@meta _',
    "error('Cannot require a meta file')",
    '-- automatically generated by mia.metagen',
  }
end

function F.mia()
  local fmt = {
    mia = Formatter('mia.%s = ... ---@module "%s"'),
    alias = Formatter('mia.%s = mia.%s'),
    util = Formatter('mia.%s = util.%1'),
  }
  local get_name = mia.F.pass(mia.tbl.index('modname'))
  local pkgs = mia.tbl.categorize(mia.package.list(), 'kind')
  return Iter({
    "_G.mia = ... ---@module 'mia'",
    'mia.lazy = mia',
    Iter(pkgs):map(function(k, ps)
      return ('\n-- %s packages'):format(k), Iter(ps):map(get_name):map(fmt.mia):totable()
    end):totable(),
    '\n-- aliases',
    sort(Iter(mia.config.aliases):map(fmt.alias):totable()),
    "\nlocal util = ... ---@module 'mia.util'",
    sort(Iter(mia.util):map(fmt.util):totable()),
  }):totable()
end

function F.auevents()
  local doc = vim.api.nvim_get_runtime_file('*/autocmd.txt', true)[1]
  local lines = vim.fn.readfile(doc)

  local ilines = Iter(lines):enumerate()
  local first = ilines:find(function(i, line)
    return line:match('^%s*%*events%* %*{event}%*$') and i
  end) + 2
  local last = ilines:find(function(i, line)
    return line:match('^===+$') and i
  end) - 1

  local aliases, events = {}, {}
  local ev, desc, alias
  for _, line in ipairs(vim.list_slice(lines, first, last)) do
    if ev and events[ev]:sub(-1) == '.' then
      ev = nil
    end

    if line:find('^%u%w+ or') then
      ev, alias, desc = line:match('^(%u%w+) or (%w+)%s+([^.]+%.?)')
      events[ev] = desc
      aliases[ev] = alias
    elseif line:find('^%u%w+') then
      ev, desc = line:match('^(%u%w+)%s+([^.]+%.?)')
      events[ev] = desc
    elseif ev and line:match('^%s+') then
      events[ev] = events[ev] .. ' ' .. line:match('^%s+([^.]+%.?)')
    end
  end

  for e, a in pairs(aliases) do
    events[a] = events[e] .. ' (alias for ' .. e .. ')'
    events[e] = events[e] .. ' (alias for ' .. a .. ')'
  end

  return { '---@alias autocmd.event', sort(Iter(events):map(Formatter('---|"%s" %s')):totable()) }
end

function F.hlgroups()
  local hexpat = string.rep('[%da-fA-F]', 6)
  local _nohex = function(name)
    return not (name:match('^' .. hexpat .. '$') or name:match('^0x' .. hexpat .. '$'))
  end

  local _hl_desc = function(name, hl)
    if hl.link then
      return name, ('links to "%s"'):format(hl.link)
    end

    local desc, mods = {}, {}
    for k, v in pairs(hl) do
      if type(v) == 'number' then
        table.insert(desc, ('%s: #%x'):format(k, v))
      elseif type(v) == 'boolean' then
        table.insert(mods, ('%s%s'):format(v and '' or 'no', k))
      end
    end

    if #mods > 0 then
      return name, table.concat(desc, ', ') .. ', mods: ' .. table.concat(mods, ', ')
    end
    return name, table.concat(desc, ', ')
  end

  return {
    '---@alias mia.hlgroup',
    sort(Iter(vim.api.nvim_get_hl(0, {})) --
      :filter(_nohex)
      :map(_hl_desc)
      :map(Formatter('---|"%s" %s'))
      :totable()),
  }
end

local function get()
  return Iter(F._order) -- key names
    :map(mia.F.index(F)) -- get the functions
    :map(mia.F.call) -- get the results in order
    :map(mia.partial(mia.tbl.insert, nil, '')) -- add a newline after each
    :flatten(math.huge)
    :totable()
end

local function write()
  local lines = get()
  local fname = vim.fn.stdpath('config') .. '/lua/mia/_meta_gen.lua'
  local metafile = io.open(fname, 'w')
  if metafile then
    metafile:write(table.concat(lines, '\n'))
    metafile:close()
    mia.info('Wrote meta file to ' .. fname)
  else
    mia.err('Could not open meta file for writing: ' .. fname)
  end
end

return {
  get = get,
  write = write,
  fmt = F,
}
